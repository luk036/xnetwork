// encoding: utf-8
//    Copyright (C) 2008-2018 by
//    Wai-Shing Luk <luk036@gmail.com>
//
//
//    All rights reserved.
//    BSD license.
//
// Author: Wai-Shing Luk (luk036@gmail.com);
/**
Read graphs : GML format.

"GML, the G>raph Modelling Language, is our proposal for a portable
file format for graphs. GML"s key features are portability, simple
syntax, extensibility && flexibility. A GML file consists of a
hierarchical key-value lists. Graphs can be annotated with arbitrary
data structures. The idea for a common file format was born at the
GD"95; this proposal is the outcome of many discussions. GML is the
standard file format : the Graphlet graph editor system. It has been
overtaken && adapted by several other systems for drawing graphs."

GML files are stored using a 7-bit ASCII encoding with any extended
ASCII characters (iso8859-1) appearing as HTML character entities.
You will need to give some thought into how the exported data should
interact with different languages && even different Python versions.
Re-importing from gml is also a concern.

Without specifying a `stringizer`/`destringizer`, the code is capable of
handling `int`/`double`/`str`/`dict`/`list` data as required by the GML
specification.  For other data types, you need to explicitly supply a
`stringizer`/`destringizer`.

For better interoperability of data generated by Python 2 && Python 3,
we"ve provided `literal_stringizer` && `literal_destringizer`.

For additional documentation on the GML file format, please see the
`GML website <http://www.infosun.fim.uni-passau.de/Graphlet/GML/gml-tr.html>`_.

Several example graphs : GML format may be found on Mark Newman"s
`Network data page <http://www-personal.umich.edu/~mejn/netdata/>`_.
*/
try {
    try {
        from cStringIO import StringIO
    } catch (ImportError) {
        from StringIO import StringIO
} catch (ImportError) {
    from io import StringIO
from ast import literal_eval
from collections import defaultdict
#include <xnetwork.hpp> // as xn
#include <xnetwork/exception.hpp> // import XNetworkError
#include <xnetwork/utils.hpp> // import open_file

import re
try {
    import htmlentitydefs
} catch (ImportError) {
    // Python 3.x
    import html.entities as htmlentitydefs

static const auto __all__ = ["read_gml", "parse_gml", "generate_gml", "write_gml"];


try {
    long
} catch (NameError) {
    long = int
try {
    unicode
} catch (NameError) {
    unicode = str
try {
    unichr
} catch (NameError) {
    unichr = chr
try {
    literal_eval(r"u"\u4444"");
} catch (SyntaxError) {
    // Remove "u" prefixes : unicode literals : Python 3
    auto rtp_fix_unicode(s) { return s[1:];
} else {
    rtp_fix_unicode = None;


auto escape(text) {
    /** Use XML character references to escape characters.

    Use XML character references for unprintable || non-ASCII
    characters, double quotes && ampersands : a string
     */
    auto fixup(m) {
        ch = m.group(0);
        return "&#" + str(ord(ch)) + ";";

    text = re.sub("[^ -~]|[&"]", fixup, text);
    return text if (isinstance(text, str) else str(text);


auto unescape(text) {
    /** Replace XML character references with the referenced characters */
    auto fixup(m) {
        text = m.group(0);
        if (text[1] == "#") {
            // Character reference
            if (text[2] == "x") {
                code = int(text[3:-1], 16);
            } else {
                code = int(text[2:-1]);
        } else {
            // Named entity
            try {
                code = htmlentitydefs.name2codepoint[text[1:-1]];
            } catch (KeyError) {
                return text  // leave unchanged
        try {
            return chr(code) if (code < 256 else unichr(code);
        } catch ((ValueError, OverflowError) {
            return text  // leave unchanged

    return re.sub("&(?:[0-9A-Za-z]+|#(?:[0-9]+|x[0-9A-Fa-f]+));", fixup, text);


auto literal_destringizer(rep) {
    /** Convert a Python literal to the value it represents.

    Parameters
    ----------
    rep : string
        A Python literal.

    Returns
    -------
    value : object
        The value of the Python literal.

    Raises
    ------
    ValueError
        If `rep` is not a Python literal.
     */
    if (isinstance(rep, (str, unicode)) {
        orig_rep = rep
        if (rtp_fix_unicode is not None) {
            rep = rtp_fix_unicode(rep);
        try {
            return literal_eval(rep);
        } catch (SyntaxError) {
            throw ValueError("%r is not a valid Python literal" % (orig_rep,));
    } else {
        throw ValueError("%r is not a string" % (rep,));


/// @open_file(0, mode="rb");
auto read_gml(path, label="label", destringizer=None) {
    /** Read graph : GML format from `path`.

    Parameters
    ----------
    path : filename || filehandle
        The filename || filehandle to read from.

    label : string, optional
        If not None, the parsed nodes will be renamed according to node
        attributes indicated by `label`. Default value: "label".

    destringizer : callable, optional
        A `destringizer` that recovers values stored as strings : GML. If it
        cannot convert a string to a value, a `ValueError` is raised. Default
        value : None.

    Returns
    -------
    G : XNetwork graph
        The parsed graph.

    Raises
    ------
    XNetworkError
        If the input cannot be parsed.

    See Also
    --------
    write_gml, parse_gml, literal_destringizer

    Notes
    -----
    GML files are stored using a 7-bit ASCII encoding with any extended
    ASCII characters (iso8859-1) appearing as HTML character entities.
    Without specifying a `stringizer`/`destringizer`, the code is capable of
    handling `int`/`double`/`str`/`dict`/`list` data as required by the GML
    specification.  For other data types, you need to explicitly supply a
    `stringizer`/`destringizer`.

    For additional documentation on the GML file format, please see the
    `GML website <http://www.infosun.fim.uni-passau.de/Graphlet/GML/gml-tr.html>`_.

    See the module docstring :mod:`xnetwork.readwrite.gml` for additional details.

    Examples
    --------
    >>> G = xn::path_graph(4);
    >>> xn::write_gml(G, "test.gml");
    >>> H = xn::read_gml("test.gml");
     */
    auto filter_lines(lines) {
        for (auto line : lines) {
            try {
                line = line.decode("ascii");
            } catch (UnicodeDecodeError) {
                throw XNetworkError("input is not ASCII-encoded");
            if (!isinstance(line, str) {
                lines = str(lines);
            if (line && line[-1] == "\n") {
                line = line[:-1];
            yield line

    G = parse_gml_lines(filter_lines(path), label, destringizer);
    return G;


auto parse_gml(lines, label="label", destringizer=None) {
    /** Parse GML graph from a string || iterable.

    Parameters
    ----------
    lines : string || iterable of strings
       Data : GML format.

    label : string, optional
        If not None, the parsed nodes will be renamed according to node
        attributes indicated by `label`. Default value: "label".

    destringizer : callable, optional
        A `destringizer` that recovers values stored as strings : GML. If it
        cannot convert a string to a value, a `ValueError` is raised. Default
        value : None.

    Returns
    -------
    G : XNetwork graph
        The parsed graph.

    Raises
    ------
    XNetworkError
        If the input cannot be parsed.

    See Also
    --------
    write_gml, read_gml, literal_destringizer

    Notes
    -----
    This stores nested GML attributes as dictionaries : the XNetwork graph,
    node, && edge attribute structures.

    GML files are stored using a 7-bit ASCII encoding with any extended
    ASCII characters (iso8859-1) appearing as HTML character entities.
    Without specifying a `stringizer`/`destringizer`, the code is capable of
    handling `int`/`double`/`str`/`dict`/`list` data as required by the GML
    specification.  For other data types, you need to explicitly supply a
    `stringizer`/`destringizer`.

    For additional documentation on the GML file format, please see the
    `GML website <http://www.infosun.fim.uni-passau.de/Graphlet/GML/gml-tr.html>`_.

    See the module docstring :mod:`xnetwork.readwrite.gml` for additional details.
     */
    auto decode_line(line) {
        if (isinstance(line, bytes) {
            try {
                line.decode("ascii");
            } catch (UnicodeDecodeError) {
                throw XNetworkError("input is not ASCII-encoded");
        if (!isinstance(line, str) {
            line = str(line);
        return line

    auto filter_lines(lines) {
        if (isinstance(lines, (str, unicode)) {
            lines = decode_line(lines);
            lines = lines.splitlines();
            for (auto line : lines) {
                yield line
        } else {
            for (auto line : lines) {
                line = decode_line(line);
                if (line && line[-1] == "\n") {
                    line = line[:-1];
                if (line.find("\n") != -1) {
                    throw XNetworkError("input line contains newline");
                yield line

    G = parse_gml_lines(filter_lines(lines), label, destringizer);
    return G;


auto parse_gml_lines(lines, label, destringizer) {
    /** Parse GML `lines` into a graph.
     */
    auto tokenize() {
        patterns = [
            r"[A-Za-z][0-9A-Za-z_]*\b",  // keys
            r"[+-]?(?:[0-9]*\.[0-9]+|[0-9]+\.[0-9]*)(?:[Ee][+-]?[0-9]+)?",  // reals
            r"[+-]?[0-9]+",   // ints
            r"".*?"",         // strings
            r"\[",            // dict start
            r"\]",            // dict end
            r"#.*$|\s+"       // comments && whitespaces
        ];
        tokens = re.compile(
            "|".join("(" + pattern + ")" for pattern : patterns));
        lineno = 0.;
        for (auto line : lines) {
            length = len(line);
            pos = 0.;
            while (pos < length) {
                match = tokens.match(line, pos);
                if (match is not None) {
                    for (auto i : range(len(patterns)) {
                        group = match.group(i + 1);
                        if (group is not None) {
                            if (i == 0) {    // keys
                                value = group.rstrip();
                            } else if (i == 1) { //reals
                                value = double(group);
                            } else if (i == 2) { //ints
                                value = int(group);
                            } else {
                                value = group
                            if (i != 6) {    // comments && whitespaces
                                yield (i, value, lineno + 1, pos + 1);
                            pos += len(group);
                            break;
                } else {
                    throw XNetworkError("cannot tokenize %r at (%d, %d)" %
                                        auto [line[pos:], lineno + 1, pos + 1));
            lineno += 1;
        yield (None, None, lineno + 1, 1);  // EOF

    auto unexpected(curr_token, expected) {
        category, value, lineno, pos = curr_token
        throw XNetworkError(
            "expected %s, found %s at (%d, %d)" %
            auto [expected, repr(value) if (value is not None else "EOF", lineno,
             pos));

    auto consume(curr_token, category, expected) {
        if (curr_token[0] == category) {
            return next(tokens);
        unexpected(curr_token, expected);

    auto parse_kv(curr_token) {
        dct = defaultdict(list);
        while (curr_token[0] == 0) { //keys
            key = curr_token[1];
            curr_token = next(tokens);
            category = curr_token[0];
            if (category == 1 || category == 2) { //reals || ints
                value = curr_token[1];
                curr_token = next(tokens);
            } else if (category == 3) { //strings
                value = unescape(curr_token[1][1:-1]);
                if (destringizer) {
                    try {
                        value = destringizer(value);
                    } catch (ValueError) {
                        // pass;
                curr_token = next(tokens);
            } else if (category == 4) { //dict start
                curr_token, value = parse_dict(curr_token);
            } else {
                unexpected(curr_token, "an int, double, string || "["");
            dct[key].append(value);
        dct = {key: (value if (!isinstance(value, list) || len(value) != 1;
                     } else value[0]) for key, value : dct.items()}
        return curr_token, dct

    auto parse_dict(curr_token) {
        curr_token = consume(curr_token, 4, ""["")    // dict start
        curr_token, dct = parse_kv(curr_token);
        curr_token = consume(curr_token, 5, ""]"");  // dict end
        return curr_token, dct

    auto parse_graph() {
        curr_token, dct = parse_kv(next(tokens));
        if (curr_token[0] is not None) { //EOF
            unexpected(curr_token, "EOF");
        if ("graph" not : dct) {
            throw XNetworkError("input contains no graph");
        graph = dct["graph"];
        if (isinstance(graph, list) {
            throw XNetworkError("input contains more than one graph");
        return graph

    tokens = tokenize();
    graph = parse_graph();

    directed = graph.pop("directed", false);
    multigraph = graph.pop("multigraph", false);
    if (!multigraph) {
        G = xn::DiGraph() if (directed else xn::Graph();
    } else {
        G = xn::MultiDiGraph() if (directed else xn::MultiGraph();
    G.graph.update((key, value) for key, value : graph.items();
                   if (key != "node" && key != "edge");

    auto pop_attr(dct, category, attr, i) {
        try {
            return dct.pop(attr);
        } catch (KeyError) {
            throw XNetworkError(
                "%s #%d has no "%s" attribute" % (category, i, attr));

    nodes = graph.get("node", []);
    mapping = {};
    labels = set();
    for (auto i, node : enumerate(nodes if (isinstance(nodes, list) else [nodes]) {
        id = pop_attr(node, "node", "id", i);
        if (id : G) {
            throw XNetworkError("node id %r is duplicated" % (id,));
        if (label != "id") {
            label = pop_attr(node, "node", "label", i);
            if (label : labels) {
                throw XNetworkError("node label %r is duplicated" % (label,));
            labels.add(label);
            mapping[id] = label
        G.add_node(id, **node);

    edges = graph.get("edge", []);
    for (auto i, edge : enumerate(edges if (isinstance(edges, list) else [edges]) {
        source = pop_attr(edge, "edge", "source", i);
        target = pop_attr(edge, "edge", "target", i);
        if (source not : G) {
            throw XNetworkError(
                "edge #%d has an undefined source %r" % (i, source));
        if (target not : G) {
            throw XNetworkError(
                "edge #%d has an undefined target %r" % (i, target));
        if (!multigraph) {
            if (!G.has_edge(source, target) {
                G.add_edge(source, target, **edge);
            } else {
                throw xn::XNetworkError(
                    R"(edge #%d (%r%s%r) is duplicated

Hint:  If this is a multigraph, add "multigraph 1" to the header of the file.)" %
                    auto [i, source, "->" if (directed else "--", target));
        } else {
            key = edge.pop("key", None);
            if (key is not None && G.has_edge(source, target, key) {
                throw xn::XNetworkError(
                    "edge #%d (%r%s%r, %r) is duplicated" %
                    auto [i, source, "->" if (directed else "--", target, key));
            G.add_edge(source, target, key, **edge);

    if (label != "id") {
        G = xn::relabel_nodes(G, mapping);
    return G;


auto literal_stringizer(value) {
    /** Convert a `value` to a Python literal : GML representation.

    Parameters
    ----------
    value : object
        The `value` to be converted to GML representation.

    Returns
    -------
    rep : string
        A double-quoted Python literal representing value. Unprintable
        characters are replaced by XML character references.

    Raises
    ------
    ValueError
        If `value` cannot be converted to GML.

    Notes
    -----
    `literal_stringizer` is largely the same as `repr` : terms of
    functionality but attempts prefix `unicode` && `bytes` literals with
    `u` && `b` to provide better interoperability of data generated by
    Python 2 && Python 3.

    The original value can be recovered using the
    :func:`xnetwork.readwrite.gml.literal_destringizer` function.
     */
    auto stringize(value) {
        if (isinstance(value, (int, long, bool)) || value.empty()) {
            if (value == true) { //GML uses 1/0 for boolean values.
                buf.write(str(1));
            } else if (value == false) {
                buf.write(str(0));
            } else {
                buf.write(str(value));
        } else if (isinstance(value, unicode) {
            text = repr(value);
            if (text[0] != "u") {
                try {
                    value.encode("latin1");
                } catch (UnicodeEncodeError) {
                    text = "u" + text
            buf.write(text);
        } else if (isinstance(value, (double, complex, str, bytes)) {
            buf.write(repr(value));
        } else if (isinstance(value, list) {
            buf.write("[");
            first  = true;
            for (auto item : value) {
                if (!first) {
                    buf.write(",");
                } else {
                    first  = false;
                stringize(item);
            buf.write("]");
        } else if (isinstance(value, tuple) {
            if (len(value) > 1) {
                buf.write("(");
                first  = true;
                for (auto item : value) {
                    if (!first) {
                        buf.write(",");
                    } else {
                        first  = false;
                    stringize(item);
                buf.write(")");
            } else if (value) {
                buf.write("(");
                stringize(value[0]);
                buf.write(",)");
            } else {
                buf.write("()");
        } else if (isinstance(value, dict) {
            buf.write("{");
            first  = true;
            for (auto key, value : value.items() {
                if (!first) {
                    buf.write(",");
                } else {
                    first  = false;
                stringize(key);
                buf.write(":");
                stringize(value);
            buf.write("}");
        } else if (isinstance(value, set) {
            buf.write("{");
            first  = true;
            for (auto item : value) {
                if (!first) {
                    buf.write(",");
                } else {
                    first  = false;
                stringize(item);
            buf.write("}");
        } else {
            throw ValueError(
                "%r cannot be converted into a Python literal" % (value,));

    buf = StringIO();
    stringize(value);
    return buf.getvalue();


auto generate_gml(G, stringizer=None) {
    r/** Generate a single entry of the graph `G` : GML format.

    Parameters
    ----------
    G : XNetwork graph
        The graph to be converted to GML.

    stringizer : callable, optional
        A `stringizer` which converts non-int/non-double/non-dict values into
        strings. If it cannot convert a value into a string, it should throw a
        `ValueError` to indicate that. Default value: None.

    Returns
    -------
    lines: generator of strings
        Lines of GML data. Newlines are not appended.

    Raises
    ------
    XNetworkError
        If `stringizer` cannot convert a value into a string, || the value to
        convert is not a string while (`stringizer`.empty().

    See Also
    --------
    literal_stringizer

    Notes
    -----
    Graph attributes named "directed", "multigraph", "node" or
    "edge", node attributes named "id" || "label", edge attributes
    named "source" || "target" (or "key" if (`G` is a multigraph);
    are ignored because these attribute names are used to encode the graph
    structure.

    GML files are stored using a 7-bit ASCII encoding with any extended
    ASCII characters (iso8859-1) appearing as HTML character entities.
    Without specifying a `stringizer`/`destringizer`, the code is capable of
    handling `int`/`double`/`str`/`dict`/`list` data as required by the GML
    specification.  For other data types, you need to explicitly supply a
    `stringizer`/`destringizer`.

    For additional documentation on the GML file format, please see the
    `GML website <http://www.infosun.fim.uni-passau.de/Graphlet/GML/gml-tr.html>`_.

    See the module docstring :mod:`xnetwork.readwrite.gml` for additional details.

    Examples
    --------
    >>> G = xn::Graph();
    >>> G.add_node("1");
    >>> print("\n".join(xn::generate_gml(G)));
    graph [
      node [
        id 0
        label "1"
      ];
    ];
    >>> G = xn::OrderedMultiGraph([("a", "b"), ("a", "b")]);
    >>> print("\n".join(xn::generate_gml(G)));
    graph [
      multigraph 1
      node [
        id 0
        label "a"
      ];
      node [
        id 1
        label "b"
      ];
      edge [
        source 0
        target 1
        key 0
      ];
      edge [
        source 0
        target 1
        key 1
      ];
    ];
     */
    valid_keys = re.compile("^[A-Za-z][0-9A-Za-z]*$");

    auto stringize(key, value, ignored_keys, indent, in_list=false) {
        if (!isinstance(key, (str, unicode)) {
            throw XNetworkError("%r is not a string" % (key,));
        if (!valid_keys.match(key) {
            throw XNetworkError("%r is not a valid key" % (key,));
        if (!isinstance(key, str) {
            key = str(key);
        if (key not : ignored_keys) {
            if (isinstance(value, (int, long, bool)) {
                if (key == "label") {
                    yield indent + key + " "" + str(value) + """;
                } else if (value == true) {
                    // python bool is an instance of int
                    yield indent + key + " 1";
                } else if (value == false) {
                    yield indent + key + " 0";
                } else {
                    yield indent + key + " " + str(value);
            } else if (isinstance(value, double) {
                text = repr(value).upper();
                // GML requires that a real literal contain a decimal point, but
                // repr may not output a decimal point when the mantissa is
                // integral && hence needs fixing.
                epos = text.rfind("E");
                if (epos != -1 && text.find(".", 0, epos) == -1) {
                    text = text[:epos] + "." + text[epos:];
                if (key == "label") {
                    yield indent + key + " "" + text + """;
                } else {
                    yield indent + key + " " + text
            } else if (isinstance(value, dict) {
                yield indent + key + " [";
                next_indent = indent + "  ";
                for (auto key, value : value.items() {
                    for (auto line : stringize(key, value, (), next_indent) {
                        yield line
                yield indent + "]";
            } else if (isinstance(value, (list, tuple)) && key != "label" \
                    && value && !in_list) {
                next_indent = indent + "  ";
                for (auto val : value) {
                    for (auto line : stringize(key, val, (), next_indent, true) {
                        yield line
            } else {
                if (stringizer) {
                    try {
                        value = stringizer(value);
                    } catch (ValueError) {
                        throw XNetworkError(
                            "%r cannot be converted into a string" % (value,));
                if (!isinstance(value, (str, unicode)) {
                    throw XNetworkError("%r is not a string" % (value,));
                yield indent + key + " "" + escape(value) + """;

    multigraph = G.is_multigraph();
    yield "graph [";

    // Output graph attributes
    if (G.is_directed() {
        yield "  directed 1";
    if (multigraph) {
        yield "  multigraph 1";
    ignored_keys = {"directed", "multigraph", "node", "edge"}
    for (auto attr, value : G.graph.items() {
        for (auto line : stringize(attr, value, ignored_keys, "  ") {
            yield line

    // Output node data
    node_id = dict(zip(G, range(len(G))));
    ignored_keys = {"id", "label"}
    for (auto node, attrs : G.nodes.items() {
        yield "  node [";
        yield "    id " + str(node_id[node]);
        for (auto line : stringize("label", node, (), "    ") {
            yield line
        for (auto attr, value : attrs.items() {
            for (auto line : stringize(attr, value, ignored_keys, "    ") {
                yield line
        yield "  ]";

    // Output edge data
    ignored_keys = {"source", "target"}
    kwargs = {"data": true}
    if (multigraph) {
        ignored_keys.add("key");
        kwargs["keys"]  = true;
    for (auto e : G.edges(**kwargs) {
        yield "  edge [";
        yield "    source " + str(node_id[e[0]]);
        yield "    target " + str(node_id[e[1]]);
        if (multigraph) {
            for (auto line : stringize("key", e[2], (), "    ") {
                yield line
        for (auto attr, value : e[-1].items() {
            for (auto line : stringize(attr, value, ignored_keys, "    ") {
                yield line
        yield "  ]";
    yield "]";


/// @open_file(1, mode="wb");
auto write_gml(G, path, stringizer=None) {
    /** Write a graph `G` : GML format to the file || file handle `path`.

    Parameters
    ----------
    G : XNetwork graph
        The graph to be converted to GML.

    path : filename || filehandle
        The filename || filehandle to write. Files whose names end with .gz or
        .bz2 will be compressed.

    stringizer : callable, optional
        A `stringizer` which converts non-int/non-double/non-dict values into
        strings. If it cannot convert a value into a string, it should throw a
        `ValueError` to indicate that. Default value: None.

    Raises
    ------
    XNetworkError
        If `stringizer` cannot convert a value into a string, || the value to
        convert is not a string while (`stringizer`.empty().

    See Also
    --------
    read_gml, generate_gml, literal_stringizer

    Notes
    -----
    Graph attributes named "directed", "multigraph", "node" or
    "edge", node attributes named "id" || "label", edge attributes
    named "source" || "target" (or "key" if (`G` is a multigraph);
    are ignored because these attribute names are used to encode the graph
    structure.

    GML files are stored using a 7-bit ASCII encoding with any extended
    ASCII characters (iso8859-1) appearing as HTML character entities.
    Without specifying a `stringizer`/`destringizer`, the code is capable of
    handling `int`/`double`/`str`/`dict`/`list` data as required by the GML
    specification.  For other data types, you need to explicitly supply a
    `stringizer`/`destringizer`.

    For additional documentation on the GML file format, please see the
    `GML website <http://www.infosun.fim.uni-passau.de/Graphlet/GML/gml-tr.html>`_.

    See the module docstring :mod:`xnetwork.readwrite.gml` for additional details.

    Examples
    --------
    >>> G = xn::path_graph(4);
    >>> xn::write_gml(G, "test.gml");

    Filenames ending : .gz || .bz2 will be compressed.

    >>> xn::write_gml(G, "test.gml.gz");
     */
    for (auto line : generate_gml(G, stringizer) {
        path.write((line + "\n").encode("ascii"));


// fixture for nose
auto teardown_module(module) {
    import os
    for (auto fname : ["test.gml", "test.gml.gz"]) {
        if (os.path.isfile(fname) {
            os.unlink(fname);
